Multi Threading:
================
Multi Tasking:
==============
* The process of executing several tasks simentaniously is called multitasking.

Multitaking is divided into two categories:
===========================================
1. process based multi tasking
2. thread based multi tasking

1. Process based multi tasking:
===============================
* Executing several tasks simentaniously where each task  is a seperate independent program or process.
ex: 1. typing java program in ide
	2. listen audio 
	3. downloading a file from net.
	
* perform simentaniously but there is no dependent on each other.
* this kind of multitasking applicable for os level.

2. Thread based multitasking:
=============================
* Executing serveral tasks simentaniously where each task is a seperate independent part of the same program or process is called thread based multitasking.
* Each independent part is called "Thread".

Application areas of multithreading are:
========================================
1. to develop animations.
2. to develop vedio games.
3. to develop web&application servers.


Thread:
=======
Thread is a flow of execution for every thread there is a seperate independent job.

ways to define a thread:
========================
1. By extending Thread Class.
2. By implementing Runnable Interface.

1. By extending thread Class:
=============================
ex:

case1:Thread Scheduler:
========================
* It is responsible for schedule the threads i,e if multiple threads are waiting to get a chance of execution then in which order threads will be executed is decided by thread scheduler

case2: difference between t.start() and t.run():
================================================
* In the case of t.start() a new thread is created which is the responsible for execution of run method.
* but in case of t.run() new thread wont create and run() method will call just like normal methodcall by main thread. Hence o/p will child thread followed by main thread.

case3: importance if thread class start method:
===============================================
* Thread class start method is responsible to register with the Thread Scheduler & all other manditary activities hence without executing the Thread class start() method there is no chance of starting a new thread in java
* due to this thread class "start()" method is considered as heart of multithreading.

case4:
======
* overloading run method is always possible but thread class start() method can invoke no-args run method.
* other will call normall using method call by main thread.
* same way main method overloading is possibel bu jvm will exucute (String[] args)

case5: if we not override run method:
=====================================
class MyThread extends Thread{
	
}
* Thread class run method will be executed which as empty implementation. Hence we won't get any o/p.


case6: overriding start() method:
=================================
* it will be executed just like normale method call.
* it si not recomended.

case7: overriding start() method and when we call super.start():
=================================================
* o/p nit expected.

case8: life cycle of thread:
============================
new/born thread  t.start()   run/runnable state  
				----------> 					
if thraed scheduler allocates processor     running state
----------------------------------------->
if run() method completed  dead state
------------------------->  

* this is simple life cycle of thread

case9:Imp
-========
* After starting a thread if we are trying to restart same thread then we wil get RE saying illegalThreadStateException. 


2. Defining a Thread by implementing Runnable interface:
========================================================
* the runnale interface present in java.lang package & it contains only one method run().

					     Runnable
						^         ^
						|          |
						|		implements
						|			|
			already implements        MyThread
				|
			Thraed
			^
			|
		  extends
			|
		MyThread
		
		
* Which Approach is best :
==========================
* Amoung two ways of defining a thread implements runnnable approach is recomended.

* In the first approach our class always extends Thread class, there is no chance extending any other class we lost inheritence.
* but in 2 way we can extend any other class  here we won't misss inheritence benifit so here this is recomended.

Getting & Setting name of a Thread:
===================================
* Every thread in java has some name. it may default name generated by jvm or customized name given by programmer.
* we can get & set a name if therad using following two methods.
1. public final String getName();
2. public final void setName(String name);
ex:
===
class MyThread extends Thread(){
}
psvm(){
	syso(Thread.currentThread().getName());
	MyThread t= new MyThread();
	syso(t.getName());
	Thread.currentThread().setName("hello");
	syso(Thread.currentThread().getName());
}

* when exception generate it will tell "exception in hello" not main.
* we cna get current executing thread object usign Thread.currentThread().
ex:
===
using Thread.currentThread().getName();

Thread priorities:
==================
* Every thread in java has some priority it may br default generated by jvm or customized priority given by programmer.

* The valid range if thread priority 1 to 10. where 1 is min priority and 10 is max priority.

Thread.MIN_PRIORITY - 1
Thread.NORM_PRIORITY - 5
Thread.MAX_PRIORITY - 10

* thread scheduler will use these priorities while allocating processor.
* thread having heighest priority this will get chance first.
* if two thread as same priority we cann't except the execution order it will depends on "thraed scheduler"

* following methods.
1. public final int getPriority();
2. public final void setPriority(int p);

ex:
===
t.setPriority(2); - correct
t.setPriority(17); - RE IllegalArgumentException

* Default priority of main thread - 5.
* for all thread default priority inherited from parent to child (same as parent).
*some platform won't support for priorities.
ex:
===
using getPriority and setPriority - for child setPriority(10)


The method to prevent thread execution:
=======================================
1. yield();
2. join();
3. sleep();


1. yield:
=========
* cause too puse the current executing thread to give the chance for waiting threads of same priority. if there is no waiting thread or all waiting threads have low priority then same thread can continue ots exception.

* If multiple threads are waiting with same prioprity then which waiting thread will get a chance we can't expect it depends on thread seceduler.

* prototype:
============
public static native void yield(); - native means not implemented in java.
										Thread.yeild()
										|
new/born thread  t.start()   run/runnable state  |
				----------> 					 |
if thraed scheduler allocates processor     running state
----------------------------------------->
if run() method completed  dead state
------------------------->  
ex:
===
class MyThread extends Thread{
	p v run(){
		for(int i=0;i<10;i++){
			sys("Child");
			Thraed.yeild();
		}
	}
}
* o/p here thread always yeild() now main will more chance than child thread.

2. join():
==========
* If thread wants to wait until completing some other thread then we should go for join() method.

for ex:
=======
* If a thread t1 wants to wait until completing t2 then t1 has to call [t2.join()].
* If t1 executes [t2.join] then immediately t1 is entered into waiting state until t2 completes.

prototype:
==========
public final void join();thrown Interpted Exception
public final void join(long ms);
public final void join(long ms, int ns);

* every join method throws interpted execption compulrosy  
we shpuld hanlde exception using catch or throws else get CE.

								|-----Waiting state
					if t1 completes					|
					if time expries				t1.join()
					if waiting thred got interputed.			t1.join(2000);
								|		t1.join(2000,1000);
								|		
								|
new/born thread  t.start()   run/runnable state  	|
				----------> 						|
if thraed scheduler allocates processor     running state
----------------------------------------->		
if run() method completed  dead state			
------------------------->  					
													
													
ex:
===
class MyThread extends Thread {
    public void run() {
        for (int i = 1; i <= 3; i++) {
            try {
                Thread.sleep(500);  // just to slow down execution
            } catch (InterruptedException e) {
                System.out.println(" interrupted.");
            }
        }
        System.out.println(" finished.");
    }
}

public class JoinExample {
    public static void main(String[] args) {
        MyThread t1 = new MyThread();

        t1.start();
        try {
            t1.join();  // main thread waits until t1 finishes
        } catch (InterruptedException e) {
            e.printStackTrace();
        }

        System.out.println("All threads finished. Main thread ends.");
    }
}


case2: waiting if child thread until completing main thread:
=====================================================
class myThread extends Thread{
	static Thread mt;
	public void m1(){
		try{
			mt.join();
		}catch(){
		
		}
		//code
	}
}

class threadjoin(){
	psvm(){
		myThread.mt = Thread.currentThread();
		myThread t =new myThread();
		t.start();
		for(int i=0; i<10;i++){
			syso("main thread");
			Thread.sleep(2000);
		}
	}
}

* Here child thread waits until main thread completion.

case3:
======
* If main thread calls join() method on child thread object and child thread calles the join method on main thread object & the proggram will be stucked this is something like "deadlock".

ex:
===
case4:
======
Thread class join method on a same thred itself then the program will stucked is something like "deadlock".
ex:
===
classs test{
	psvm(){
		Thread.currentThread().join();
		syso("main thread");
	}
}

3. sleep():
===========
* If thread do not want to perform any operation for a perticular amount of time then we should go for "sleep()" method.

prototype:
==========
public static native void sleep(long ms) throws IE;
public static void sleep(long ms, int ns) throws IE;

1 millisecond = 1,000,000 nanoseconds,
1000 ms = 1 second

ns range(0â€“999,999)


diagram
=======

ex:
===

how a thread can interrupte the another thread:
===============================================
* A thread can interupt a  sleeping thread or a waiting thread by using "interupt()"method of thread class.
prototype:
==========
public void interrupt();

ex:
===
class MyThread extends Thread {
    public void run() {
        try {
            for (int i = 1; i <= 5; i++) {
                System.out.println("Thread running... iteration " + i);
                Thread.sleep(1000); // Simulate some work
            }
        } catch (InterruptedException e) {
            System.out.println("Thread was interrupted! Cleaning up...");
        }
        System.out.println("Thread ends.");
    }
}

public class InterruptExample {
    public static void main(String[] args) {
        MyThread t = new MyThread();
        t.start();

        try {
            Thread.sleep(3000); // Let the thread run for a while
        } catch (InterruptedException e) {
            e.printStackTrace();
        }

        System.out.println("Main thread interrupts child thread.");
        t.interrupt();  // Interrupt the thread
    }
}

cases:
======
* when ever we calling interrupt method if the target thread not in sleeping state or waiting state.then there is no implact of interrupt call immediately enterupted call will be waited until targets thread entered into sleepting or waiting state.
* If the target thread enter into sleeping or waiting state then immediately interpt call will interpt the target thread.
* If the target thread never entered into sleeping or waiting state in its lige cycle then tre is no interupt call this is the only case interrupt caall will be wasted.

class MyThread extends Thread {
    public void run() {
	for (int i = 1; i <= 10000; i++) {
                System.out.println("Thread running... iteration " + i);
             
            }
        try {
               Thread.sleep(1000); // Simulate some work
        } catch (InterruptedException e) {
            System.out.println("Thread was interrupted! Cleaning up...");
        }
        System.out.println("Thread ends.");
    }
}

public class InterruptExample {
    public static void main(String[] args) {
        MyThread t = new MyThread();
        t.start();
        System.out.println("Main thread interrupts child thread.");
        t.interrupt();  // Interrupt the thread
    }
}
* In the above example "interupt call" waiteed until child thread completes for loop 10,000 times.


Differences:
============
1. Yeild(): if a thread wants to pause its execution to give the chance for tha remain threads of same priority then go for yeild().

2. Join(): if a thread wants to wait until completing some other thread then we should go for join method.

3. if a thread don't perform any operaion per a perticular amount of tim then we should for for sleep method.

Synchronization:
================
* Synchronized is the modifier applicable only for methods & blocks but not for classes and variables.
* If multiple threads are trying to operate saimentaneously
on the sam java object then thre may be a chance of "data inconsistency problem". to over come we should go for "synchronized" keyword.
* Internally synchronization concept is implemented by using lock every object in java has a unique lock. when ever we are using synchronized keyword then only lock concept come into picture.
* If thread wants to execute synchronized method on the given object first it has to get lockof that object once thread got the lock then it is allowed to execute any synchronized method on that object.
* Once method is completed automatically thread releases lock threads are allowed to executes non-synchronized methods 
* accuring and relaseing lock is taken care by jvm and programmer is not responsible.
* while thread executing synchronized method on the given object the remaining threads are not allowed to executes any synchronized method simultaneously on the same object but remaing simultaneously.
* lock conecpt is implemented based on object not method.
* every objetc ahs two state sync and non-sync 

prototype:
==========
class X{
	synchronized{
		where ever we performs update operation add|rename|delete i,e where state of object is changing.
	}
	non-sync{
		where every object won't be changes like read().
	}
}

ex:
===
class Display{
	public void wish(String name){ // do for synchronized
		for(int i=0;i<10;i++){
			syso("good morning");
			try{
				Thread.sleep(2000);
			}
			catch(Interrupt Exception e){
			}
			syso(name);
		}
	}
}
class MyThread extends Thread{
	Display d;
	String name;
	MyThread(Display d , String s){
		this.d=d;
		this.s=s;
	}
	public void run(){
		d.wish(name);
	}
}
class Main{
	psvm(){
		Display d = new Display();
		MyThread t1 = new MyThread(d,"mohan");
		MyThread t2 = new MyThread(d,"yuvaraj");
		t1.start();
		t2.start();
	}
}

case1:
======
different objects
class Main{
	psvm(){
		Display d1 = new Display();
		Display d2 = new Display();
		MyThread t1 = new MyThread(d1,"mohan");
		MyThread t2 = new MyThread(d2,"yuvaraj");
		t1.start();
		t2.start();
	}
}
* synchronized but get irregukar o/p because of different object.
conclusion:
===========
* if multiple threads operating on the same java object then synchronization is required else not.

case3:
======
class level lock:
=================
* Every class in java has unique lock, which is nothing but class level lock.
* If a thread wants to executes "static sync method" then thread required class level lock.
* Once thread got class level lock then this allowed to execute any static sync method after tahat release.


class Display{
	public static synchronized void wish(String name){
		for(int i=0;i<10;i++){
			syso("good morning");
			try{
				Thread.sleep(2000);
			}
			catch(Interrupt Exception e){
			}
			syso(name);
		}
	}
}

synchronized block:
===================
* if very few lines of code required synchronization then it is not recomended declare entire method synchronized. we have to enclose those few lines of code by using syncronized block.
1. to get lock of current object:
=================================
synchronized(this){

}

2. to get perticular object:
============================
synchronized(p){

}

3. to get class lock:
============================
synchronized(Display.class){

}